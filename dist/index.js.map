{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import uuid from 'uuid-random';\nimport { version } from '../package.json';\n\nenum ActionMetaType {\n    REQUEST = 'request',\n    RESPONSE = 'response',\n}\n\ntype ActionMeta = {\n    type: ActionMetaType;\n    external: boolean;\n    async?: boolean;\n    error?: boolean;\n    id?: string;\n};\n\ntype Action = {\n    id?: string;\n    type?: string;\n    payload?: object | any;\n    meta?: ActionMeta;\n};\n\ntype DispatchFunction = (action: Action) => Promise<any>;\ntype MessageReceiveFunction = (message: string | object) => undefined | never;\n\ntype PostMessageHandler = (message: string, action: Action) => void | never;\n\ntype Bridge = {\n    version: string;\n    sync: any;\n    dispatch: DispatchFunction;\n    dispatchAsync: DispatchFunction;\n    setPostMessage: (postMessage: PostMessageHandler) => void;\n    subscribe: (listener: Function) => Function;\n    onMessage: MessageReceiveFunction;\n    listenEvent: (type: string, handler: Function) => Function;\n};\n\ntype BridgeOptions = {\n    postMessage?: PostMessageHandler;\n};\n\ntype EventHandlerDoneCallback = (action: Action) => void;\ntype EventHandlerErrorCallback = (error: Error | string | object) => void;\n\ntype EventHandler =\n    | ((action: Action, done: EventHandlerDoneCallback, error: EventHandlerErrorCallback) => void)\n    | ((action: Action) => void);\n\ntype Middleware = (bridge: Bridge) => (next: (action: Action) => Promise<any>) => (action: Action) => Promise<any>;\n\ntype SyncResponse =\n    | {\n          version: string;\n          otherSideVersion: string;\n      }\n    | never;\n\nexport function compose(...funcs) {\n    if (funcs.length === 0) {\n        return (arg) => arg;\n    }\n\n    funcs = funcs.filter((func) => typeof func === 'function');\n\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n\n    return funcs.reduce(\n        (a, b) =>\n            (...args) =>\n                a(b(...args)),\n    );\n}\n\nconst Logger = (() => {\n    const prefix = '[webview-bridge]';\n    return {\n        log: (...args) => console.log(prefix, ...args),\n        warn: (...args) => console.warn(prefix, ...args),\n        error: (...args) => console.error(prefix, ...args),\n    };\n})();\n\nconst warnNoAsyncMessageResponse = (action: Action) => {\n    Logger.error(\n        `Cannot make a response. To be able to response to action '${action.type}' please dispatch it using 'dispatchAsync' bridge method.`,\n    );\n};\n\nconst warnNoPostMessageProvided = (message: string, action: Action) =>\n    Logger.warn(\n        `Cannot dispatch action '${action.type}. 'Please provide post message implementation calling 'bridge.setPostMessage' first.`,\n    );\n\nconst SYNC_MESSAGE = '@@INTERNAL_SYNC_MESSAGE';\n\nconst createBridge = (options: BridgeOptions, middlewares: Array<Middleware>): Bridge => {\n    let postMessage = options?.postMessage ?? warnNoPostMessageProvided;\n\n    let listeners = [];\n\n    const subscribe = (listener) => {\n        listeners.push(listener);\n\n        return () => {\n            listeners = listeners.filter((current) => current !== listener);\n        };\n    };\n\n    let eventListeners = {};\n\n    const listenEvent = (type: string, handler: EventHandler) => {\n        const eventListenerId = uuid();\n        eventListeners[type] = eventListeners[type] ?? {};\n        eventListeners[type][eventListenerId] = handler;\n\n        return () => {\n            delete eventListeners[type][eventListenerId];\n        };\n    };\n\n    const internalDispatch = (action: Action) => {\n        const { meta, type } = action;\n\n        if (!meta.external) {\n            try {\n                const serializedMessage = JSON.stringify(action);\n                postMessage(serializedMessage, action);\n            } catch (e) {\n                throw e;\n            }\n        }\n\n        if (meta.type === ActionMetaType.REQUEST && meta.external) {\n            if (eventListeners[type]) {\n                let resolved = false;\n\n                const done = ((responseAction) => {\n                    const { type = action.type, payload, meta } = responseAction ?? {};\n\n                    if (resolved) {\n                        Logger.warn(`You're trying to resolve async request that is already done.`);\n                        return;\n                    }\n                    resolved = true;\n                    localResponseDispatch({\n                        type,\n                        payload,\n                        meta: {\n                            ...meta,\n                            id: action.id,\n                        },\n                    });\n                }) as EventHandlerDoneCallback;\n\n                const error = ((errorResponse) => {\n                    if (resolved) {\n                        Logger.warn(`You're trying to reject async request that is already done.`);\n                        return;\n                    }\n                    resolved = true;\n                    const isError = errorResponse instanceof Error;\n                    const isString = typeof errorResponse === 'string';\n                    const isAction = !(isError || isString || !errorResponse);\n                    const { type, payload, meta = {} } = (isAction ? errorResponse : {}) as Action;\n\n                    let serializedError;\n\n                    switch (true) {\n                        case isError:\n                            serializedError = {\n                                message: errorResponse.toString(),\n                            };\n                            break;\n                        case isString:\n                            serializedError = {\n                                message: errorResponse,\n                            };\n                            break;\n                        default:\n                            serializedError = payload;\n                    }\n\n                    localResponseDispatch({\n                        type: type ?? action.type,\n                        payload: serializedError,\n                        meta: { ...meta, id: action.id, error: true } as ActionMeta,\n                    });\n                }) as EventHandlerErrorCallback;\n\n                const warnArgumentUsage = () => warnNoAsyncMessageResponse(action);\n                const doneCallback = meta.async ? done : warnArgumentUsage;\n                const errorCallback = meta.async ? error : warnArgumentUsage;\n\n                const listeners = Object.values(eventListeners[type]) as Array<EventHandler>;\n\n                listeners.forEach((listener) => listener(action, doneCallback, errorCallback));\n            }\n        }\n    };\n\n    let bridge = {} as Bridge;\n\n    const listenMiddleware = (() => (next) => (action) => {\n        listeners.forEach((listener) => {\n            listener(action);\n        });\n        return next(action);\n    }) as Middleware;\n\n    const chain = [listenMiddleware, ...middlewares].map((middleware) => middleware(bridge));\n\n    const wrappedDispatch = compose(...chain)(internalDispatch);\n\n    const localRequestDispatch = ((action) => {\n        const { type, payload = {} } = action;\n        const id = uuid();\n        const meta = {\n            ...(action.meta ?? {}),\n            external: false,\n            type: ActionMetaType.REQUEST,\n        } as ActionMeta;\n\n        return wrappedDispatch({ id, type, payload, meta } as Action);\n    }) as DispatchFunction;\n\n    const localResponseDispatch = ((action) => {\n        const { type, payload = {}, meta = {} } = action;\n        const id = uuid();\n\n        return wrappedDispatch({\n            id,\n            type,\n            payload,\n            meta: {\n                ...meta,\n                external: false,\n                type: ActionMetaType.RESPONSE,\n            } as ActionMeta,\n        });\n    }) as DispatchFunction;\n\n    const localRequestDispatchAsync = ((action) => {\n        return localRequestDispatch({\n            ...action,\n            meta: { ...(action.meta ?? {}), async: true } as ActionMeta,\n        });\n    }) as DispatchFunction;\n\n    const externalDispatch = ((action) => {\n        return wrappedDispatch({\n            ...action,\n            meta: {\n                ...(action.meta ?? {}),\n                external: true,\n            },\n        });\n    }) as DispatchFunction;\n\n    const onMessage = ((message) => {\n        try {\n            const action = typeof message === 'string' ? JSON.parse(message) : message;\n            externalDispatch(action as Action);\n        } catch (error) {\n            throw error;\n        }\n    }) as MessageReceiveFunction;\n\n    const setPostMessage = (nextPostMessage: PostMessageHandler): void => {\n        postMessage = nextPostMessage;\n    };\n\n    const sync = async (timeout = 5000): Promise<SyncResponse> => {\n        const version = await Promise.race([\n            (async () => {\n                const { version } = await bridge.dispatchAsync({\n                    type: SYNC_MESSAGE,\n                    payload: { version: bridge.version },\n                });\n                return version;\n            })(),\n            new Promise((resolve) => {\n                setTimeout(() => resolve(false), timeout);\n            }),\n        ]);\n\n        if (version === false) {\n            throw new Error(\n                'Error: AsyncBridge.sync timeout. AsyncBridge was not able to receive response from the other side.',\n            );\n        }\n\n        return {\n            version: bridge.version,\n            otherSideVersion: version,\n        };\n    };\n\n    listenEvent(SYNC_MESSAGE, ({ payload }, done) => {\n        done({ payload: { version: bridge.version } });\n    });\n\n    bridge = {\n        version,\n        sync,\n        dispatch: localRequestDispatch,\n        dispatchAsync: localRequestDispatchAsync,\n        setPostMessage,\n        subscribe,\n        onMessage,\n        listenEvent,\n    };\n\n    return bridge;\n};\n\nconst loggerMiddleware = (() => (next) => (action) => {\n    Logger.log('action:', action);\n    return next(action);\n}) as Middleware;\n\nconst asyncMiddleware = (() => {\n    const awaitMap = {};\n\n    return (next) => (action) => {\n        // returning promise for async request action\n        if (action?.meta?.async && action?.meta?.type === ActionMetaType.REQUEST && !action?.meta?.external) {\n            const id = action?.id;\n\n            return new Promise((resolve, reject) => {\n                awaitMap[id] = {\n                    resolve: (payload) => {\n                        resolve(payload);\n                        delete awaitMap[id];\n                    },\n                    reject: (error) => {\n                        reject(error);\n                        delete awaitMap[id];\n                    },\n                };\n\n                next(action);\n            });\n            // solving promise in case if received response action with same id\n        } else if (action?.meta?.type === ActionMetaType.RESPONSE && action?.meta?.external) {\n            const id = action?.meta?.id;\n\n            if (awaitMap[id]) {\n                if (!action.meta.error) {\n                    awaitMap[id].resolve(action.payload);\n                } else {\n                    awaitMap[id].reject(action.payload);\n                }\n            } else {\n                return next(action);\n            }\n        } else {\n            return next(action);\n        }\n    };\n}) as Middleware;\n\nexport function createAsyncBridge(options: BridgeOptions = {}, middlewares: Array<Middleware> = []): Bridge {\n    return createBridge(options, [asyncMiddleware, ...middlewares]);\n}\n"],"names":["compose","funcs","arg","func","a","b","args","Logger","prefix","warnNoAsyncMessageResponse","action","warnNoPostMessageProvided","message","SYNC_MESSAGE","createBridge","options","middlewares","postMessage","listeners","subscribe","listener","current","eventListeners","listenEvent","type","handler","eventListenerId","uuid","internalDispatch","meta","serializedMessage","e","resolved","done","responseAction","payload","localResponseDispatch","error","errorResponse","isError","isString","isAction","serializedError","warnArgumentUsage","doneCallback","errorCallback","bridge","chain","next","middleware","wrappedDispatch","localRequestDispatch","id","localRequestDispatchAsync","externalDispatch","onMessage","setPostMessage","nextPostMessage","sync","timeout","version","resolve","asyncMiddleware","awaitMap","_a","_b","_c","reject","_d","_e","_f","createAsyncBridge"],"mappings":"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"}