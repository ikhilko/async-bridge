{"version":3,"file":"index.umd.cjs","sources":["../src/index.ts"],"sourcesContent":["import uuid from 'uuid-random';\nimport { version } from '../package.json';\n\nenum ActionMetaType {\n    REQUEST = 'request',\n    RESPONSE = 'response',\n}\n\ntype ActionMeta = {\n    type: ActionMetaType;\n    external: boolean;\n    async?: boolean;\n    error?: boolean;\n    id?: string;\n};\n\ntype Action = {\n    id?: string;\n    type?: string;\n    payload?: object | any;\n    meta?: ActionMeta;\n};\n\ntype DispatchFunction = (action: Action) => Promise<any>;\ntype MessageReceiveFunction = (message: string | object) => undefined | never;\n\ntype PostMessageHandler = (message: string, action: Action) => void | never;\n\ntype Bridge = {\n    version: string;\n    sync: any;\n    dispatch: DispatchFunction;\n    dispatchAsync: DispatchFunction;\n    setPostMessage: (postMessage: PostMessageHandler) => void;\n    subscribe: (listener: Function) => Function;\n    onMessage: MessageReceiveFunction;\n    listenEvent: (type: string, handler: Function) => Function;\n};\n\ntype BridgeOptions = {\n    postMessage?: PostMessageHandler;\n};\n\ntype EventHandlerDoneCallback = (action: Action) => void;\ntype EventHandlerErrorCallback = (error: Error | string | object) => void;\n\ntype EventHandler =\n    | ((action: Action, done: EventHandlerDoneCallback, error: EventHandlerErrorCallback) => void)\n    | ((action: Action) => void);\n\ntype Middleware = (bridge: Bridge) => (next: (action: Action) => Promise<any>) => (action: Action) => Promise<any>;\n\ntype SyncResponse =\n    | {\n          version: string;\n          otherSideVersion: string;\n      }\n    | never;\n\nexport function compose(...funcs) {\n    if (funcs.length === 0) {\n        return (arg) => arg;\n    }\n\n    funcs = funcs.filter((func) => typeof func === 'function');\n\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n\n    return funcs.reduce(\n        (a, b) =>\n            (...args) =>\n                a(b(...args)),\n    );\n}\n\nconst Logger = (() => {\n    const prefix = '[webview-bridge]';\n    return {\n        log: (...args) => console.log(prefix, ...args),\n        warn: (...args) => console.warn(prefix, ...args),\n        error: (...args) => console.error(prefix, ...args),\n    };\n})();\n\nconst warnNoAsyncMessageResponse = (action: Action) => {\n    Logger.error(\n        `Cannot make a response. To be able to response to action '${action.type}' please dispatch it using 'dispatchAsync' bridge method.`,\n    );\n};\n\nconst warnNoPostMessageProvided = (message: string, action: Action) =>\n    Logger.warn(\n        `Cannot dispatch action '${action.type}. 'Please provide post message implementation calling 'bridge.setPostMessage' first.`,\n    );\n\nconst SYNC_MESSAGE = '@@INTERNAL_SYNC_MESSAGE';\n\nconst createBridge = (options: BridgeOptions, middlewares: Array<Middleware>): Bridge => {\n    let postMessage = options?.postMessage ?? warnNoPostMessageProvided;\n\n    let listeners = [];\n\n    const subscribe = (listener) => {\n        listeners.push(listener);\n\n        return () => {\n            listeners = listeners.filter((current) => current !== listener);\n        };\n    };\n\n    let eventListeners = {};\n\n    const listenEvent = (type: string, handler: EventHandler) => {\n        const eventListenerId = uuid();\n        eventListeners[type] = eventListeners[type] ?? {};\n        eventListeners[type][eventListenerId] = handler;\n\n        return () => {\n            delete eventListeners[type][eventListenerId];\n        };\n    };\n\n    const internalDispatch = (action: Action) => {\n        const { meta, type } = action;\n\n        if (!meta.external) {\n            try {\n                const serializedMessage = JSON.stringify(action);\n                postMessage(serializedMessage, action);\n            } catch (e) {\n                throw e;\n            }\n        }\n\n        if (meta.type === ActionMetaType.REQUEST && meta.external) {\n            if (eventListeners[type]) {\n                let resolved = false;\n\n                const done = ((responseAction) => {\n                    const { type = action.type, payload, meta } = responseAction ?? {};\n\n                    if (resolved) {\n                        Logger.warn(`You're trying to resolve async request that is already done.`);\n                        return;\n                    }\n                    resolved = true;\n                    localResponseDispatch({\n                        type,\n                        payload,\n                        meta: {\n                            ...meta,\n                            id: action.id,\n                        },\n                    });\n                }) as EventHandlerDoneCallback;\n\n                const error = ((errorResponse) => {\n                    if (resolved) {\n                        Logger.warn(`You're trying to reject async request that is already done.`);\n                        return;\n                    }\n                    resolved = true;\n                    const isError = errorResponse instanceof Error;\n                    const isString = typeof errorResponse === 'string';\n                    const isAction = !(isError || isString || !errorResponse);\n                    const { type, payload, meta = {} } = (isAction ? errorResponse : {}) as Action;\n\n                    let serializedError;\n\n                    switch (true) {\n                        case isError:\n                            serializedError = {\n                                message: errorResponse.toString(),\n                            };\n                            break;\n                        case isString:\n                            serializedError = {\n                                message: errorResponse,\n                            };\n                            break;\n                        default:\n                            serializedError = payload;\n                    }\n\n                    localResponseDispatch({\n                        type: type ?? action.type,\n                        payload: serializedError,\n                        meta: { ...meta, id: action.id, error: true } as ActionMeta,\n                    });\n                }) as EventHandlerErrorCallback;\n\n                const warnArgumentUsage = () => warnNoAsyncMessageResponse(action);\n                const doneCallback = meta.async ? done : warnArgumentUsage;\n                const errorCallback = meta.async ? error : warnArgumentUsage;\n\n                const listeners = Object.values(eventListeners[type]) as Array<EventHandler>;\n\n                listeners.forEach((listener) => listener(action, doneCallback, errorCallback));\n            }\n        }\n    };\n\n    let bridge = {} as Bridge;\n\n    const listenMiddleware = (() => (next) => (action) => {\n        listeners.forEach((listener) => {\n            listener(action);\n        });\n        return next(action);\n    }) as Middleware;\n\n    const chain = [listenMiddleware, ...middlewares].map((middleware) => middleware(bridge));\n\n    const wrappedDispatch = compose(...chain)(internalDispatch);\n\n    const localRequestDispatch = ((action) => {\n        const { type, payload = {} } = action;\n        const id = uuid();\n        const meta = {\n            ...(action.meta ?? {}),\n            external: false,\n            type: ActionMetaType.REQUEST,\n        } as ActionMeta;\n\n        return wrappedDispatch({ id, type, payload, meta } as Action);\n    }) as DispatchFunction;\n\n    const localResponseDispatch = ((action) => {\n        const { type, payload = {}, meta = {} } = action;\n        const id = uuid();\n\n        return wrappedDispatch({\n            id,\n            type,\n            payload,\n            meta: {\n                ...meta,\n                external: false,\n                type: ActionMetaType.RESPONSE,\n            } as ActionMeta,\n        });\n    }) as DispatchFunction;\n\n    const localRequestDispatchAsync = ((action) => {\n        return localRequestDispatch({\n            ...action,\n            meta: { ...(action.meta ?? {}), async: true } as ActionMeta,\n        });\n    }) as DispatchFunction;\n\n    const externalDispatch = ((action) => {\n        return wrappedDispatch({\n            ...action,\n            meta: {\n                ...(action.meta ?? {}),\n                external: true,\n            },\n        });\n    }) as DispatchFunction;\n\n    const onMessage = ((message) => {\n        try {\n            const action = typeof message === 'string' ? JSON.parse(message) : message;\n            externalDispatch(action as Action);\n        } catch (error) {\n            throw error;\n        }\n    }) as MessageReceiveFunction;\n\n    const setPostMessage = (nextPostMessage: PostMessageHandler): void => {\n        postMessage = nextPostMessage;\n    };\n\n    const sync = async (timeout = 5000): Promise<SyncResponse> => {\n        const version = await Promise.race([\n            (async () => {\n                const { version } = await bridge.dispatchAsync({\n                    type: SYNC_MESSAGE,\n                    payload: { version: bridge.version },\n                });\n                return version;\n            })(),\n            new Promise((resolve) => {\n                setTimeout(() => resolve(false), timeout);\n            }),\n        ]);\n\n        if (version === false) {\n            throw new Error(\n                'Error: AsyncBridge.sync timeout. AsyncBridge was not able to receive response from the other side.',\n            );\n        }\n\n        return {\n            version: bridge.version,\n            otherSideVersion: version,\n        };\n    };\n\n    listenEvent(SYNC_MESSAGE, ({ payload }, done) => {\n        done({ payload: { version: bridge.version } });\n    });\n\n    bridge = {\n        version,\n        sync,\n        dispatch: localRequestDispatch,\n        dispatchAsync: localRequestDispatchAsync,\n        setPostMessage,\n        subscribe,\n        onMessage,\n        listenEvent,\n    };\n\n    return bridge;\n};\n\nconst loggerMiddleware = (() => (next) => (action) => {\n    Logger.log('action:', action);\n    return next(action);\n}) as Middleware;\n\nconst asyncMiddleware = (() => {\n    const awaitMap = {};\n\n    return (next) => (action) => {\n        // returning promise for async request action\n        if (action?.meta?.async && action?.meta?.type === ActionMetaType.REQUEST && !action?.meta?.external) {\n            const id = action?.id;\n\n            return new Promise((resolve, reject) => {\n                awaitMap[id] = {\n                    resolve: (payload) => {\n                        resolve(payload);\n                        delete awaitMap[id];\n                    },\n                    reject: (error) => {\n                        reject(error);\n                        delete awaitMap[id];\n                    },\n                };\n\n                next(action);\n            });\n            // solving promise in case if received response action with same id\n        } else if (action?.meta?.type === ActionMetaType.RESPONSE && action?.meta?.external) {\n            const id = action?.meta?.id;\n\n            if (awaitMap[id]) {\n                if (!action.meta.error) {\n                    awaitMap[id].resolve(action.payload);\n                } else {\n                    awaitMap[id].reject(action.payload);\n                }\n            } else {\n                return next(action);\n            }\n        } else {\n            return next(action);\n        }\n    };\n}) as Middleware;\n\nexport function createAsyncBridge(options: BridgeOptions = {}, middlewares: Array<Middleware> = []): Bridge {\n    return createBridge(options, [asyncMiddleware, ...middlewares]);\n}\n"],"names":["compose","funcs","arg","func","a","b","args","Logger","prefix","warnNoAsyncMessageResponse","action","warnNoPostMessageProvided","message","SYNC_MESSAGE","createBridge","options","middlewares","postMessage","listeners","subscribe","listener","current","eventListeners","listenEvent","type","handler","eventListenerId","uuid","internalDispatch","meta","serializedMessage","e","resolved","done","responseAction","payload","localResponseDispatch","error","errorResponse","isError","isString","isAction","serializedError","warnArgumentUsage","doneCallback","errorCallback","bridge","chain","next","middleware","wrappedDispatch","localRequestDispatch","id","localRequestDispatchAsync","externalDispatch","onMessage","setPostMessage","nextPostMessage","sync","timeout","version","resolve","asyncMiddleware","awaitMap","_a","_b","_c","reject","_d","_e","_f","createAsyncBridge"],"mappings":"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"}